## 7.  基于共享变量的并发

### 1. **竞争条件**

> 一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。

> 竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。

> 数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。

### 2. **互斥锁**

> 用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量（binary semaphore）。
```go
var (
    sema    = make(chan struct{}, 1) // 二元信号量
    balance int
)

func Deposit(amount int) {
    sema <- struct{}{} // 获取锁
    balance = balance + amount
    <-sema // 释放锁
}

func Balance() int {
    sema <- struct{}{} // 获取锁
    b := balance
    <-sema // 释放锁
    return b
}
```

```go
import "sync"

var (
    mu      sync.Mutex // guards balance
    balance int
)

func Deposit(amount int) {
    mu.Lock() // 获取锁
    balance = balance + amount
    mu.Unlock() // 释放锁
}

func Balance() int {
    mu.Lock() // 获取锁
    b := balance
    mu.Unlock() // 释放锁
    return b
}
```

### 3. **读写锁**

> 允许多个只读操作并行执行，但写操作会完全互斥。
```go
var mu sync.RWMutex
var balance int
func Balance() int {
    // 查看余额操作，不更改变量balance 只是读
    mu.RLock() // readers lock
    defer mu.RUnlock()
    return balance
}
```

### 4. **检查竞争条件**

> 在go build，go run或者go test命令后面加上-race的flag