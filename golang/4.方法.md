## 4. 方法

### 1. **方法声明**

> 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类 型上，即相当于为这种类型定义了一个独占的方法。

```go
type Person struct {
	Name string
	Age  int8
}

func (p Person) ShowInfo() {
	fmt.Printf("Name: %s\nAge:%d\n", p.Name, p.Age)
}
```

### 2. **基于指针对象的方法**

> 这个接受者变量本身比较大时，我们就可以用其指针而不是 对象来声明方法。

> 如个类有一个指针作为接收器的方法，那么所有这个类的方法都 必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。

```go
type Person struct {
	Name string
	Age  int8
}

func (p *Person) ShowInfo() {
	fmt.Printf("Name: %s\nAge:%d\n", p.Name, p.Age)
}
```

> 在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的
```go
type P *int

// error
func (p P) test() {

}
```

> 不能通过一个无法取到地址的接收器来调 用指针方法，比如临时变量的内存地址就无法获取得到
```go
type Person struct {
	Name string
	Age  int8
}

func (p *Person) Set(name string, age int8) {
	p.Name = name
	p.Age = age
}
// cannot call pointer method Set on Person
Person{}.Set()
```

### 3. **内嵌结构**

> 内嵌可以使我们定义字段特别多的复杂类型，我 们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。
```go
type Point struct{ X, Y float64 }
type ColoredPoint struct {
	Point
	Color color.RGBA
}
```

### 4. **封装**

> 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做 信息隐藏。

> 大写首字母的标识符会从定义它们的包中被导出，小写字母的则不 会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对 象，我们必须将其定义为一个struct。