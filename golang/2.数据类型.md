## 2. 数据类型

### 1. **整数**

- 有符号整数: int int8 int16 int32 int64
  - rune类型是int32类型同义，代表是一个Unicode码点。
  - byte类型是uint8同义，代表一个值是原始数据，而非量值。
- 无符号整数: uint uint8 uint16 uint32 uint64
  - 无符号整数通常用于位运算符和特定算术运算符，如实现位集，解析二进制文件。一般而言，无符号整数极少用于表示非负值。

### 2. **浮点数**

- float32:
  - 优先使用
  
- float64: 
  - 运算会有误差
- 通过谓词 %g 输出，%e 有指数 %f 无指数

### 3. **复数**

- complex64: 由float32构成
- complex128: 由float64构成
- real() 返回复数实部
- imag() 返回复数虚部

### 4. **布尔值**

- true
- false

- 短路行为: 如果操作符左边的操作数已经能直接确定总体结果，则右边的操作数不会计算在内。

### 5. **字符串**

- 一个字符串是一个不可改变的字节序列。尝试修改字符串内部数据的操作是被禁止的,字符串可以包含任意的数据，包括byte值0。
- 内置的len函数可以返回一个字符串中的字节数目。
- 如果试图访问超出字符串索引范围的字节将会导致panic异常。
- +操作符将两个字符串链接构造一个新字符串："hello" + "world"
- 字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。
  
- 可以通过十六进制或八进制转义在字符串面值包含任意的字节。一个十六进制的转义形式是\xhh，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是\ooo，包含三个八进制的o数字
（0到7），但是不能超过\377 (255)
- 在原生的字符串面值中(\` \`)，没有转义操作；全部的内容都是字面的意思，包含退格和换行

### 6. **unicode**

- 它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型
- UTF-8: 
  - 是一个将Unicode码点编码为字节序列的变长编码。
  - UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示总共有多少编码个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。更大的Unicode码点也是采用类似的策略处理。
  - Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：\uhhhh对应16bit的码点值，\Uhhhhhhhh对应32bit的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。
  ```go
    package main

    import (
        "fmt"
        "unicode/utf8"
    )

    func main() {
        var s string = "你好，123test"
        
        for i := 0; i < len(s); {
            // 返回rune字符 和 r的字节大小
            r, size := utf8.DecodeRuneInString(s[i:])
            fmt.Printf("%b %[1]x\n", r)
            i += size
        }

        // for range 方式打印
        for _, v := range s {
		    fmt.Printf("%s\n", string(v))
	    }

        // 程序中常用rune切片，因为rune大小一致，支持数组索引和方便切割。
        r := []rune("世界")

        // rune切片转string
        s := string(r)
    }

  ```
- 字符串和byte切片
  - 字符串和字节slice之间可以相互转换: 
    ```go
    var val string = "test"
    byteSlice := []byte(val)
    s := string(byteSlice)
    ```
  - bytes包提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要处理化。
- 字符串和数字互相转换
  - strconv.Itoa(int) int 转 string
  - strconv.ParseInt(string, base, bitSize)  将一个字符串解析为整数
  
### 6. **常量**
- 常量表达式的值在编译期计算，而不是在运行期。 ``` const pi = 3.14 ```
- iota:
  - 生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。
  - 在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。

### 7. **数组**

- 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。
  
- 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。

- 在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。

- 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。
  
    ```go
    // var array [...]int
    var array [10]int 
    for i := 0; i < len(array); i++ {
        array[i] = i + 1
    }
    for i := 0; i < len(array); i++ {
        fmt.Printf("%d\n", array[i])
    }
    ```

### 8. **slice**

-  Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T
代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。

- 一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。
  
- 内置的len和cap函数分别返回slice的长度和容量。
  
- slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。
  
- 向函数传递slice将允许在函数内部修改底层数组的
元素。

- slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。
- make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。
  ```go
    make([]int, 0, 0)
  ```
- append函数用于向slice追加元素。
  ```go
    slice := make([]int, 0)
    for i:=0; i<10; i++ {
        slice = append(slice, i)
    }
  ```

### 9. **map**

- 是一个无序的key/value对的集合，其中所有的key都是不同
的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

- map类型可以写为map[K]V，其中K和V分别对应key和
value。是key和value之间可以是不同的数据类型。中K对应的key必须是支持==比较运算符的数据类型。

- 在向map存数据前必须先创建map。

```go
    // make 函数创建
	var i map[string]string = make(map[string]string)
	i["name"] = "alice"

	// map 字面量创建
	j := map[string]string{
		"name": "erika",
	}

	// 创建空map
	z := map[string]int{}
	z["alice"] = 99

	// 删除元素
	delete(j, "name")

    // 获取元素
    name, ok := i["name"]
    if !ok {} // 没有获取到

```

### 10. **结构体**

- 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。
  
- 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。
  
- 如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，
  
    ```go
    package main

    import "fmt"

    type Employee struct {
        id      int16 // 不可被外部包访问
        Name    string
        Address string
        Salary  int16
    }


    func main() {
        // 结构体字面量
        // 两种不同形式的写法不能混合使用。

        // 要求以结构体成员定义的顺序为每个结构体成员指定一个面值。
        alice := Employee{
            1,
            "alice",
            "bj",
            3000,
        }

        // 以成员名字和相应的值来初始化，可以包含部分或全部的成员
        bob := Employee{
            id:      2,
            Name:    "bob",
            Address: "bj",
            Salary:  3502,
        }

        fmt.Println(bob)

    }

    ```
- 只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。

    ```go
    package main

    import "fmt"

    type Point struct{ X, Y int }

    type Circle struct {
        Point
        Radius int
    }

    func main() {
        a := Circle{
            Point: Point{
                X: 3,
                Y: 3,
            },
            Radius: 2,
        }
        b := Circle{
            Point{
                3,
                3,
            },
            2,
        }
        fmt.Println(a, b)
    }

    ```
### 11. **JSON**

- JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。
  
  ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "os"
    )

    type Person struct {
        Name    string   `json:"name"`
        Age     int      `json:"age"`
        Address []string `json:"address"`
    }

    func main() {
        persons := make([]Person, 0)

        p1 := Person{
            Name:    "admin",
            Age:     1,
            Address: []string{"bj", "sh"},
        }
        p2 := Person{
            Name:    "erika",
            Age:     20,
            Address: []string{"bj", "hb"},
        }

        persons = append(persons, p1, p2)

        // [{"Name":"admin","Age":1,"Address":["bj","sh"]},{"Name":"erika","Age":20,"Address":["bj","hb"]}]
        // 序列化: go struct => json
        res, err := json.MarshalIndent(persons, "", "    ")
        if err != nil {
            fmt.Println("json.Marshal")
            os.Exit(1)
        }
        fmt.Println(string(res))

        ps := make([]Person, 0)

        // 反序列化， json => go struct
        err = json.Unmarshal(res, &ps)
        if err != nil {
            fmt.Println("json.Unmarshal")
            os.Exit(1)
        }

        fmt.Println(ps)
    }

  ```