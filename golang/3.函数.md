## 3. 函数

### 1. **函数声明**
> 函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。

> 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。

> 返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。
> 
```go
func name(parameter-list) (result-list) {
    body
}

//  返回值也可以像形式参数一样被命名。（bare return）
func add(x, y int) (z int) {
    z = x + y
    return
}
``` 

### 2. **递归**

> 着函数可以直接或间接的调用自身。

### 3. **多返回值**

> 在Go中，一个函数可以返回多个值。许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。
```go

func findLinks(url string) ([]string, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    if resp.StatusCode != http.StatusOK {
        resp.Body.Close()
        return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
    }
    return visit(nil, doc), nil
}
```
> 调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:
```go
links, err := findLinks(url)
```
### 4. **错误**

> error 类型: error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型,我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。

常见的错误处理方式:
- 将错误返回给调用者:
  ```go
    func test() error {
	    return errors.New("error1")
    }
   
    if err := test(); err != nil {
        fmt.Fprintf(os.Stderr, "test: %v\n", err)
    }
  ```
- 重试失败的操作
  ```go
    func WaitForServer(url string) error {
        const timeout = 1 * time.Minute
        deadline := time.Now().Add(timeout)
        for tries := 0; time.Now().Before(deadline); tries++ {
            _, err := http.Head(url)
            if err == nil {
                return nil // success
            }
            log.Printf("server not responding (%s);retrying…", err)
            time.Sleep(time.Second << uint(tries)) // exponential back-off
        }
        return fmt.Errorf("server %s failed to respond after %s", url, timeout)
    }
  ```
- 输出错误信息并结束程序。这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序
  ```go
    if err := WaitForServer(url); err != nil {
        fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
        os.Exit(1)
    }
  ```
- 只需要输出错误信息就足够了，不需要中断程序的运行。
  ```go
    if err := Ping(); err != nil {
        log.Printf("ping failed: %v; networking disabled",err)
    }
  ```
- 直接忽略掉错误

### 5. **函数值**
> 函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。

```go
    func add(a, b int) int { return a + b }
    a1 := add
    a1(1,1)

    // strings.Map对字符串中的每个字符调用函数，并将每个函数的返回值组成一个新的字符串返回给调用者。
    func test(r rune) rune { reutrn unicdoe.ToUpper(r) }
    strings.Map(test, "hello")
```

### 6. **匿名函数**

> 函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数

```go
strings.Map(func(r rune) rune {
    return unicode.ToUpper(r)
}, "hello")
``` 

> 在函数中定义的内部函数可以引用该函数的变量(闭包)
```go
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
    
f := squares()
fmt.Println(f()) // "1"
fmt.Println(f()) // "4"
fmt.Println(f()) // "9"

```

### 7. **可变参数**

> 在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。
```go
// 在函数体中, y被看作是类型为[] int的切片
func test(x int, y ...int) {
	fmt.Println(x)

	for _, v := range y {
		fmt.Println(v)
	}
}
```

### 8. **defer**

> 当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。

> 释放资源的defer应该直接跟在请求资源的语句后。

```go
resp, err := http.Get(url)
if err != nil {
    // handle err
}
defer resp.Body.Close()
```

> 对匿名函数采用defer机制，可以使其观察函数的返回值。
```go
func add(a, b int) (res int) {
	defer func() {
		fmt.Println("res = ", res)
	}()
	res = a + b
	return
}
```

### 9. **Panic**

> 数组访问越界、空指针引用等。这些运行时错误会引起painc异常。当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。

> panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。

> 由于panic会引起程序的崩溃，因此panic一般用于严重错误

### 10. **Recover捕获异常**

> 如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。

```go
func f() (res int) {
	defer func() {
		if err := recover(); err != nil {
			val, ok := err.(int)
			if ok {
				res = val
			}

		}
	}()

	panic(int(5))
}
```