## 5. 接口

### 1. 定义

> 接口类型是一种抽象的类型。它们只会展示出它们自己的方法。也就是说当 你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。

> 接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。

```go
type byteCounter int

func (b *byteCounter) Write(p []byte) (n int, err error) {
	*b = byteCounter(len(p))
	return int(*b), nil
}
```

### 2. **空接口**

> 空接口类型对实现它 的类型没有要求，所以我们可以将任意一个值赋给空接口类型。
```go
var v interface{}

v = 123
v = "test"
v = []string{"hello", "world"}
v = map[string]string{"name": "erika"}
```

### 3. **接口值**

> 接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。
```go
// 动态类型: nil
// 动态值: nil
var w io.Writer = nil

// 动态类型: *os.File
// 动态值: 指向标准输出的文件描述符 /dev/stdout
w = os.Stdout

// 动态类型: *bytes.Buffer
// 动态值: 指向 新分配的缓冲区的指针
w = new(bytes.Buffer)
```
> 用fmt包的%T得知接口值的动态类型

### 4. **sort.Sort排序接口**

> 简单类型排序: sort.Strings sort.Ints 
> 自定义类型排序: 需实现 Len Less Swap 方法
```go
package main

import (
	"fmt"
	"sort"
)

type person struct {
	name string
	age  int8
}

type personSlice []person

func (p personSlice) Len() int {
	return len(p)
}

func (p personSlice) Less(i, j int) bool {
	return p[i].age < p[j].age
}

func (p personSlice) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

func main() {

	data := []person{
		{name: "bob", age: 25},
		{name: "erika", age: 18},
		{name: "admin", age: 21},
	}
	fmt.Println("排序前:\n", data)
	sort.Sort(personSlice(data))
	fmt.Println("排序后:\n", data)

}

```

### 5. **http.Handler接口**

```go

type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

// 创建新的路由规则
mux := http.NewServeMux()

// 使用默认路由
http.ListenAndServe(addr, nil)


http.Handle("/", http.HandlerFunc(show))
http.HandleFunc("/1", show)

```
```go
// 增删改查demo 不支持并发修改
package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
)

type dollor float64

func (d dollor) String() string {
	return fmt.Sprintf("%.2f", d)
}

type database map[string]dollor

func (d database) list(w http.ResponseWriter, r *http.Request) {
	for item, price := range d {
		fmt.Fprintf(w, "item: %10s  price: %10s\n", item, price)
	}
}

func (d database) get(w http.ResponseWriter, r *http.Request) {
	item := r.URL.Query().Get("item")

	if item == "" {
		fmt.Fprint(w, "item is nil")
		return
	}

	price, ok := d[item]
	if ok {
		fmt.Fprintf(w, "item: %10s price: %10s", item, price)
		return
	}

	fmt.Fprintf(w, "item [%s] not found\n", item)
}

func (d database) update(w http.ResponseWriter, r *http.Request) {
	item := r.URL.Query().Get("item")
	price := r.URL.Query().Get("price")

	if item == "" || price == "" {
		fmt.Fprint(w, "item or price is nil")
		return
	}

	_, ok := d[item]
	if !ok {
		fmt.Fprint(w, "item  not found")
		return
	}

	f, err := strconv.ParseFloat(price, 64)
	if err != nil {
		fmt.Fprintf(w, "price format error")
		return
	}

	d[item] = dollor(f)
	fmt.Fprintf(w, "update successed")

}

func (d database) add(w http.ResponseWriter, r *http.Request) {
	item := r.URL.Query().Get("item")
	price := r.URL.Query().Get("price")

	if item == "" || price == "" {
		fmt.Fprint(w, "item or price is nil")
		return
	}

	_, ok := d[item]
	if ok {
		fmt.Fprint(w, "item  existed")
		return
	}

	f, err := strconv.ParseFloat(price, 64)
	if err != nil {
		fmt.Fprintf(w, "price format error")
		return
	}

	d[item] = dollor(f)
	fmt.Fprintf(w, "add item [%s] successed", item)

}

func (d database) delete(w http.ResponseWriter, r *http.Request) {
	item := r.URL.Query().Get("item")

	if item == "" {
		fmt.Fprint(w, "item is nil")
		return
	}

	_, ok := d[item]
	if !ok {
		fmt.Fprint(w, "item  not found")
		return
	}

	delete(d, item)

	fmt.Fprintf(w, "delete item [%s] successed\n", item)

}
func main() {

	db := database{"shoes": 100.01, "clothes": 44.21}

	mux := http.NewServeMux()
	mux.Handle("/add", http.HandlerFunc(db.add))
	mux.Handle("/price", http.HandlerFunc(db.get))
	mux.HandleFunc("/list", db.list)
	mux.HandleFunc("/update", db.update)
	mux.HandleFunc("/delete", db.delete)

	if err := http.ListenAndServe("localhost:8888", mux); err != nil {
		log.Fatalf("http.ListenAndServe: %v\n", err)
	}

}

```

### 6. **error 接口**

```go
type error interface {
	Error() string
}
```
> 创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。
```go
func New(text string) error {
	return &errorString{text}
}
```
> 调用errors.New函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。
```go
func Errorf(format string, args ...interface{}) error {
    return errors.New(Sprintf(format, args...))
}
```

### 7. **类型断言**

> 类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
```go
var v interface{}

v = 123
v = "test"
v = 1

switch v.(type) {
case string:
    fmt.Printf("string v = %s\n", v)

case int:
    fmt.Printf("int v = %d\n", v)
}
```