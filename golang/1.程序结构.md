## 1. 程序结构

1. **名称**
   > 一个名称必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的

   > 如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。

   > 在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。

2. **声明**
   
   > 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

   ```go
    package main

    import (
        "fmt"
    )

    var globalVar = 0

    const constA = 0

    func main() {
        var localA = 0
        fmt.Println(globalVar, constA, localA)
    }
   ```
3. **变量**
   
   > var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。

   > var 变量名字 类型 = 表达式

   > “类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。

   > 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

   > “:=”是一个变量声明语句，而“=‘是一个变量赋值操作。
   ```go
    func test() {
        a := 10 // a int
    }
   ```

   > 简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

   ```golang
    func test() {
        // i err 声明并赋值
        i, err := os.Open(file)
        // out 声明并赋值 err 赋值
        out, err := os.Create(file)
        // 简短变量声明语句中必须至少要声明一个新的变量
        i, err := os.Open(file) //err
        i, err = os.Open(file) //ok
    }
   ```
4. **指针**
   
   > 一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。

   > 在Go语言中，返回函数中局部变量的地址也是安全的。
   ```go
    func test() *int {
        j := 11
        return &j
    }

    func main() {
        fmt.Println("j =", *(test())) // j = 11
    }
   ```

5. **new函数**
   
   > 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
   
   > new函数使用常见相对比较少，因为对应结构体来说，可以直接用字面量语法创建新变量的方法会更灵活
   
   ```go
    p := new(int32)
	*p = 1234
	fmt.Println(*p)
   ```
6. **变量生命周期**
   > 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。

   > 在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。

   > 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

   > 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间

7. **赋值**
   > 赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。
   ```go
    // 命令变量的赋值
    x = 1           
    // 通过指针间接赋值            
    *p = true                   
    person.name = "bob"         
    // 结构体字段赋值
    count[x] = count[x] * scale // 数组、slice或map的元素赋值
   ```

   > 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。
   ```go
   // 交换变量
    a, j = j, i
    a[i], a[j] = a[j], a[i]
   ```

   > 和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值

   ```go
    _, err = io.Copy(dst, src)
   ```

   > 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为

   ```go
    // 只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
    medals := []string{"gold", "silver", "bronze"}
    // 相当于
    medals[0] = "gold"
    medals[1] = "silver"
    medals[2] = "bronze"
   ```
8. **类型**
   > 变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

   > 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型

   ```go
    /* 一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。*/
    type 类型名字 底层类型

   ```

9. **包**
    > 一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；

    > 每个包都对应一个独立的名字空间。

    > 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。如果一个名字是大写字母开头的，那么该名字是导出的

    ```go
    // 包的导入
    import (
        （自定义包名） "项目名/包名"
    )
    ```
    > 对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。

    初始化:
    - 解决包级变量的依赖顺序，
    - 安照包级变量声明出现的顺序依次初始化：


    
   