## 6. 并发

### 1. **Goroutines**

> 在Go语言中，每一个并发的执行单元叫作一个goroutine。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。

```go
f()    // call f(); 等待返回
go f() // 创建一个新的 goroutine， 调用 f(); 不等待它返回
```

> 主函数返回时，所有的goroutine都会被直接打断，程序退出。

### 2. **channel**

> 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。

> 一个可以发送int类型数据的channel一般写为chan int。

> 单方向的channel类型，分别用于只发送或只接收的channel。类型chan<- int表示一个只发送int的channel，只能发送不能接收。相反，类型<-chan int表示一个只接收int的channel，只能接收不能发送。

```go
ch := make(chan int)

// 从通道读取数据
x, ok := <- ch

// for range 读取
for x := range ch {
    fmt.Println(x)
}

// 发送数据
ch <- 1

// 关闭通道
close(ch)
```
- **无缓冲channel**: 
    > 发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。

    > 无缓存Channels有时候也被称为同步Channels。
  ```go
    ch := make(chan int)

    done := make(chan struct{})

    go func() {
        time.Sleep(10 * time.Second)
        // 向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。
        done <- struct{}{}
    }()

    fmt.Println("Hello, Go!")
    <-done
    fmt.Println("main done")
  ```
- **缓冲channel**: 向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。
  ```go
    ch := make(chan int, 1)
    ch <- 3

    fmt.Println(<-ch)

    // demo
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    func test() {

        type item struct {
            worker int
            err    error
        }

        var wg sync.WaitGroup
        ch := make(chan item, 10)

        for i := 0; i < 10; i++ {
            wg.Add(1)
            // worker
            go func(i int) {
                defer wg.Done()

                fmt.Println("i=", i, "work...")
                time.Sleep(10 * time.Second)

                ch <- item{
                    worker: i,
                    err:    nil,
                }

            }(i)
        }

        go func() {
            wg.Wait()
            close(ch)
        }()

        for val := range ch {
            fmt.Printf("worker: %d error: %v\n", val.worker, val.err)
        }
    }
    func main() {
        test()
    }

  ```
### 3. **select**

> select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。

> 如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。
```go
select {
case <-ch1:
    // ...
case x := <-ch2:
    // ...use x...
case ch3 <- y:
    // ...
// 有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。
default:
    // ...
}
```