
## 进程

### 1. 进程定义
>进程是由内核定义的抽象实体，并为该实体分配用以执行程序所需要的各种系统资源。 （运行在内存中的程序称之为进程）

### 2. 进程id
>每个进程都有一个进程号，进程号是一个正数，用以标识系统中的一个进程
  ```c
    #include <sys/types.h>
    #include <unistd.h>

    // 获取进程pid
    pid_t getpid(void);
    // 获取父进程pid
    pid_t getppid(void);
  ```

### 3. 进程内存布局

> 每个进程内存所分配的内存由很多部分组成，称之为段(segment)
> 1. 文本段(text): 包括了程序运行时需要的机器指令，文本段具有只读属性，因为多个进程可运行同一程序，所以又将文本段设置为共享，一分程序代码的拷贝可映射到所有这些进程的虚拟空间当中。
> 2. 初始化数据段(data): 包括显式初始化的全局变量和静态变量，程序运行时，当程序加载到内存时，从可执行文件读取这些变量的值。
> 3. 未初始化数据段(bss): 未经显式初始化的全局变量和静态变量，程序启动前，系统将本段的内存初始化为0。
> 4. 栈段(stack): 是一个动态增长的段，系统为每个当前调用的函数分配一个栈帧，栈帧存储了函数的局部变量，实参和返回值。
> 5. 堆(heap): 运行时动态进行内存分配的一块区域，堆顶端称之为program break。
---

![alt text](image-1.png)

---

```c
    #include <stdio.h>
    #include <stdlib.h>

    // data segment
    char data_var[1000] = {'d'};

    // bss
    char bss_var[1000];

    int main(int argc, char *argv[]) {
        // stack frame
        char stack_var[1000] = {'a'};

                                // heap
        char *heap_var = (char *)malloc(sizeof(char) * 1000);
        if (heap_var == NULL) {
            printf("malloc error\n");
            return -1;
        }

        free(heap_var);

        return 0;
}
    // size a.out 
    // text    data     bss     dec     hex filename
    // 2011    1640    1032    4683    124b a.out
```

### 4. 虚拟内存

> 1. 将每个程序使用的内存切割成小型的、固定大小的“页”（page）单元。
> 2. 将 RAM 划分成一系列与虚存页尺寸相同的页帧
> 3. 任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。
> 4. 程序未使用的页拷贝保存在交换区（swap area）内—这是磁盘空间中的保留区域，作为计算机 RAM 的补充— 仅在需要时才会载入物理内存。
> 5. 若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。

> 内核需要为每个进程维护一个页表。

![](image-2.png)

> 使用虚拟内存的优点:
> - 进程之间相互隔离， 所以一个进程不能读取或修改另一个进程的内存。
> - 适当情况下，两个进程之间可以共享内存。 (进程间通信)
> - 便于实现内存保护机制；也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。
> - 程序员和编译器、链接器之类的工具无需关注程序在 RAM 中的物理布局
> - 因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存（即虚拟内存大小）能够超出 RAM 容量。

### 5. 栈和栈帧

> 栈从高地址向低地址生长。
>
> 寄存器—栈指针（stack pointer），用于跟踪当前栈顶。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。
>

### 6. 非局部跳转 (setjmp / longjmp)

> 非局部（nonlocal）” 是指跳转的目标为当前执行函数之外的某个位置
>
> 在一个深度嵌套的函数调用中发生了错误，需要放弃当前任务，从多层函数调用中返回 需使用longjmp
> 
> 在调用这些函数时，为避免编译器优化所引发的问题，应使用 volatile 修饰符声明变量。非局部跳转会使程序难于阅读和维护，应尽量避免使用。

```c
    #include <setjmp.h>

    int setjmp(jmp_buf env);
    void longjmp(jmp_buf env, int val);
```
```c
    // setjmp / longjmp demo
    #include <stdio.h>
    #include <setjmp.h>

    jmp_buf jmp;

    int test();
    int test1();
    int test2();

    int test() {
        printf("func test\n");
        test1();
    }

    int test1() {
        printf("func test1\n");
        test2();    
    }

    int test2() {
        printf("func test2\n");
        longjmp(jmp, 1);
    }

    int main(int argc, char *argv[]) {
        
        switch (setjmp(jmp))
        {
        case 0:
            // 初次调用setjmp 返回0 
            printf("main\n");
            test();
            break;
        case 1:
            printf("从test2函数返回\n");
            break;
        default:
            break;
        }
        return 0;
    }
```

### 7.进程的创建

1. **fork**
   
   > fork()通过复制一个与调用进程(父进程)几乎完全一致的拷贝来创建一个新进程 (子进程)。
    
   > 执行 fork()时，子进程会获得父进程所有文件描述符的副本。

   > 如果子进程更新了文件偏移量，那么这种改变也会影响到父进程中相应的描述符。

   > 不应对 fork()之后执行父、子进程的特定顺序做任何假设。

   ```c
    #include <sys/types.h>
    #include <unistd.h>

    // 两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。
    // 执行 fork() 之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。
    pid_t fork(void);
    
    //demo 
    pid_t childpid;
    switch (childpid = fork())
    {
    case 0:
        // 子进程
        break;
    case -1:
        // 处理错误
        break;
    default:
        break;
    }
    
   ```

### 8. 进程的终止

1. **_exit**
   
   ```c
    #include <unistd.h>

    // 退出程序
    void _exit(int status);
   ```

2. **exit**

   ```c
    #include <stdlib.h>
    
    // 退出流程
    // 调用退出处理程序(通过 atexit()和 on_exit()注册的函数)，其执行顺序与注册顺序相反
    // 刷新 stdio 流缓冲区。
    // 使用由 status 提供的值执行_exit()系统调用。
    void exit(int status);
   ```
3. **atexit**
   
   ```c
    #include <stdlib.h>

    // 将 function 加到一个函数列表中，进程终止时会调用该函数列表的所有函数。
    int atexit(void (*function)(void));
   ```

### 9. 监控子进程

1. **等待进程退出**

   1. **wait**
   
       ```c
        #include <sys/wait.h>
        
        // 等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回 该子进程的终止状态。
        pid_t wait(int *stat_loc);
       ```

   2. **waitpid**
    
       > 可等待某个特定子进程的完成。

       > 可以阻塞等待或非阻塞等待。
       
       > 可获得因信号停止的子进程信息。

       ```c
       #include <sys/types.h>
       #include <sys/wait.h>
       
       // 如果 pid 大于 0，表示等待进程 ID 为 pid 的子进程。
       // 如果 pid 等于 0，则等待与调用进程(父进程)同一个进程组(process group)的所有 子进程。
       // 如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程。
       // 如果 pid 等于-1，则等待任意子进程。
       pid_t waitpid(pid_t pid, int *wstatus, int options);
       ```

       `options`:
       
       `WUNTRACED`: 除了返回终止子进程的信息外，还返回因信号而停止的子进程信息。

       `WCONTINUED`: 返回因收到 SIGCONT 信号而恢复执行的已停止子进程的状态信息。
        
       `WNOHANG`: 如果参数 pid 所指定的子进程并未发生状态改变，则立即返回，而不会阻塞
    
   3. **state**
      > 由 wait()和 waitpid()返回的 status 的值，可用来区分以下子进程事件。
       - 子进程调用_exit()(或 exit())而终止，并指定一个整型值作为退出状态。
       - 子进程收到未处理信号而终止。
       - 子进程因为信号而停止，并以 WUNTRACED 标志调用 waitpid()。
       - 子进程因收到信号 SIGCONT 而恢复，并以 WCONTINUED 标志调用 waitpid()。
  
        <br />

        ```c
        // 子进程正常结束则返回真(true)。
        WIFEXITED (status)

        // 返回子进程的退出 状态。
        WEXITSTATUS(status)

        // 通过信号杀掉子进程则返回真(true)。
        WIFSIGNALED (status)

        // 返回导致子进程终止 的信号编号。
        WTERMSIG(status)

        // 子进程因信号而停止，则此宏返回为真值(true)。 
        WIFSTOPPED (status)

        // 子进程收到 SIGCONT 而恢复执行，则此宏返回真值(true)。
        WIFCONTINUED (status)
        ```

2. **孤儿进程和僵尸进程**
   
   > 进程 ID 为 1 的init会接管孤儿进程。

   > 子进程退出后，父进程未执行wait系列函数获取子进程退出信息后内核把子进程转为僵尸进程。

3. **回收进程方法（通过SIGCHLD信号）**
   
   ```c
    //在信号处理程序中
    while (waitpid(-1, NULL,WNOHANG) > 0)
        continue;
   ```

4. **忽略终止的子进程**
   
   > (Solaris 8) 对 SIGCHLD 的处置显式置为 SIG_ IGN，系统从而会将其后终止的子进程立即删除，不转为僵尸进程。

### 10. 执行新程序

1. **exec系列函数**
   
   > 将新程序加载到某一进程的内存空间。在这一操作过程中，将丢弃 旧有程序，而进程的栈、数据以及堆段会被新程序的相应部件所替换。

   > 默认情况下，由 exec()的调用程序所打开的所有文件描述符在 exec()的执行过程中会保持 打开状态，且在新程序中依然有效。

   > 内核为每个文件描述符提供了执行时关闭标志(FD_CLOEXEC )。如果设置了这一标志，那么在成 功执行 exec()时，会自动关闭该文件描述符，如果调用 exec()失败，文件描述符则会保持打开 状态。

   > exec()在执行时会将现有进程的文本段丢弃。该文本段可能包含了由调用进程创建的信号 处理器程序。既然处理器已经不知所踪，内核就会将对所有已设信号的处置重置为 SIG_DFL。

   ```c
    #include <unistd.h>


    int execl(const char *pathname, const char *arg, ...
                    /* (char  *) NULL */);
    int execlp(const char *file, const char *arg, ...
                    /* (char  *) NULL */);
    int execle(const char *pathname, const char *arg, ...
                    /*, (char *) NULL, char *const envp[] */);
    int execv(const char *pathname, char *const argv[]);

    int execvp(const char *file, char *const argv[]);
   ```

   ![alt text](<image-9.png>)
2. **执行shell命令**
   
   ```c
    #include <stdlib.h>

    int system(const char *command);

    返回值:
        * 当command为NULL指针时，如果shell可用则system()返回非0值，若不可用则返回0。
        * 如果无法创建子进程或是无法获取其终止状态，那么 system()返回-1。
        * 若子进程不能执行shell，则system()的返回值会与子shell调用_exit(127)终止时一样。
        * 如果所有的系统调用都成功，system()会返回执行 command 的子 shell 的终止状态。

   ```

### 11. 进程凭证

1. **实际用户ID和实际组ID**
   
   > 实际用户ID和实际组ID确定了进程所属的用户和组。作为登录过程的步骤之一，登录shell从/etc/passwd 文件中读取相应用户密码记录的第三字段和第四字段，置为其实际用户ID和实际组ID。当创建新进程时，将从其父进程中继承这些 ID。

2. **有效用户ID 和有效组ID**
   
   > 当进程尝试执行各种操作（即系统调用）时，将结合有效用户 ID、有效组 ID，连同辅助组 ID 一起来确定授予进程的权限。

   > 有效用户 ID 为 0（root 的用户 ID）的进程拥有超级用户的所有权限。这样的进程又称为特权级进程。而某些系统调用只能由特权级进程执行。

3. **Set-User-ID和Set-Group-ID程序**
   
   >  set-user-ID 程序会将进程的有效用户 ID 置为可执行文件的用户 ID（属主），从而获得常规情况下并不具有的权限。
   > set-group-ID 程序对进程有效组 ID 实现类似任务。

4. **保存Set-User-ID和保存Set-Group-ID**
   
   > 意在与set-user-ID 和 set-group-ID 程序结合使用。

   > 若可执行文件的 set-user-ID (set-group-ID)权限位已开启，则将进程的有效用户（组）ID置为可执行文件的属主。若未设置 set-user-ID (set-group-ID)权限位，则进程的有效用户（组）ID 将保持不变。

   > 保存 set-user-ID 和保存 set-group-ID 的值由对应的有效 ID 复制而来。无论正在执行的文件是否设置了 set-user-ID 或 set-group-ID 权限位，这一复制都将进行

5. **文件系统用户ID和组ID**
   
   >  Linux系统中，要进行诸如打开文件、改变文件属主、修改文件权限之类的文件系统操作时，决定其操作权限的是文件系统用户ID 和组ID, 通常，文件系统用户ID和组ID 的值等同于相应的有效用户ID和组ID。

6. **获取和修改实际、有效和保存设置标识**
   
   ```c
    #include <unistd.h>
    #include <sys/types.h>

    // 返回调用进程的实际用户 ID 和组 ID。
    uid_t getuid(void);
    gid_t getgid(void);
    
    // 返回调用进程的有效用户 ID 和组 ID。
    uid_t geteuid(void);
    gid_t getegid(void);

    // 修改调用进程的有效用户 ID 和组 ID， 如果进程有特权，也设置实际用户ID和组ID、保存用户ID和保存组ID。
    int setuid(uid_t uid);
    int setgid(uid_t uid);

    // 修改调用进程的有效用户 ID 和组 ID。
    int seteuid(uid_t euid);
    int setegid(gid_t egid);
    
    // 允许调用进程独立修改其实际和有效用户 ID,实际组和有效组 ID 
    int setreuid(uid_t ruid, uid_t euid);
    int setregid(gid_t rgid, gid_t egid);

    #define _GNU_SOURCE         
    #include <unistd.h>

    // 将调用进程的当前实际用户 ID、有效用户 ID 和保存 set-user-ID 值返回至给定 3 个参数所指定的位置。getresgid()系统调用针对相应的组 ID 实现了类似功能。
    int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
    int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

    // 允许调用进程独立修改其 3 个用户 ID 的值。每个用户 ID 的新值由系统调用的 3 个参数给定。setresgid()系统调用对相应的组 ID 实现了类似功能。
    int setresuid(uid_t ruid, uid_t euid, uid_t suid);
    int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

    #include <sys/fsuid.h>

    // setfsuid()系统调用将进程文件系统用户 ID 修改为参数 fsuid 所指定的值。setfsgid()系统调用将文件系统组 ID 修改为参数 fsgid 所指定的值
    int setfsuid(uid_t fsuid);
    int setfsgid(uid_t fsgid);
   ```

### 12. 进程组、会话和作业控制

1. **进程组**
   
   > 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。

   ```c
    #include <sys/types.h>
    #include <unistd.h>
    
    // 获取一个进程的进程组 ID。
    // 如果getpgrp()的返回值与调用进程的进程 ID 匹配的话就说明该调用进程是其进程组的首进程。
    pid_t getpgrp(void); 

    // 如果将 pid 的值设置为 0，那么调用进程的进程组 ID 就会被改变。
    // 如果将 pgid 的值设置为 0，那么 ID 为 pid 的进程的进程组 ID 会被设置成 pid 的值。
    int setpgid(pid_t pid, pid_t pgid);
                    

   ```
2. **会话**
   
   > 会话是一组进程组的集合。进程的会话成员关系是由其会话标识符（SID）确定的,会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。

   > 一个会话中的所有进程共享单个控制终端。

   > 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。

   > 当会话首进程打开了一个控制终端之后它同时也成为了该终端的控制进程。在发生终端断开之后，内核会向控制进程发送一个 SIGHUP 信号来通知这一事件的发生。

   ```c
    #define _XOPEN_SOURCE  500
    #include <sys/types.h>
    #include <unistd.h>

    // 会返回 pid 指定的进程的会话 ID。
    pid_t getsid(pid_t pid);

    // 如果调用进程不是进程组首进程，那么 setsid()会创建一个新会话。
    pid_t setsid(void);



    #include <stdio.h>
    
    // 返回表示控制终端的路径名。
    char *ctermid(char *s);
   ```

3. **前台和后台进程组**

   > 在一个会话中，在同一时刻只有一个进程能成为前台进程，会话中的其他所有进程都是后台进程组。

   > 前台进程组是唯一能够自由地读取和写入控制终端的进程组。当在控制终端中输入其中一个信号生成终端字符之后，终端驱动器会将相应的信号发送给前台进程组的成员。

   ```c
    #include <unistd.h>

    // 获取和修改一个终端的进程组。
    pid_t tcgetpgrp(int fd);

    int tcsetpgrp(int fd, pid_t pgrp);
   ```

4. **SIGHUP信号**
   
   > 当一个控制进程失去其终端连接之后，内核会向其发送一个 SIGHUP 信号来通知它这一事实。

   > 一些任务控制 shell 在正常退出（如登出或在 shell 窗口中接下 Control-D）时也会发送SIGHUP 信号来停止后台任务。bash 和 Korn shell 都采取了这种处理方式（在首次登出尝试时打印出一条消息之后）。

   > nohup(1)命令可以用来使一个命令对 SIGHUP 信号免疫——即执行命令时将 SIGHUP 信号的处理设置为 SIG_IGN。bash 内置的命令 disown 提供了类似的功能，它从 shell 的任务列表中删除一个任务，这样在 shell 终止时就不会向该任务发送 SIGHUP 信号了。