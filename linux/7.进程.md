## 进程

### 1.进程的创建

1. **fork**
   
   > fork()通过复制一个与调用进程(父进程)几乎完全一致的拷贝来创建一个新进程 (子进程)。
    
   > 执行 fork()时，子进程会获得父进程所有文件描述符的副本。

   > 如果子进程更新了文件偏移量，那么这种改变也会影响到父进程中相应的描述符。

   > 不应对 fork()之后执行父、子进程的特定顺序做任何假设。

   ```c
    #include <sys/types.h>
    #include <unistd.h>

    // 两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。
    // 执行 fork() 之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。
    pid_t fork(void);
        成功: 夫进程返回>0, 子进程成功返回0
        失败: 返回-1, 并设置errno
    
    //demo 
    pid_t childpid;
    switch (childpid = fork())
    {
    case 0:
        // 子进程
        break;
    case -1:
        // 处理错误
        break;
    default:
        break;
    }
    
   ```

### 2. 进程的终止

1. **_exit**
   
   ```c
    #include <unistd.h>

    // 退出程序
    void _exit(int status);
   ```

2. **exit**

   ```c
    #include <stdlib.h>
    
    // 退出流程
    // 调用退出处理程序(通过 atexit()和 on_exit()注册的函数)，其执行顺序与注册顺序相反
    // 刷新 stdio 流缓冲区。
    // 使用由 status 提供的值执行_exit()系统调用。
    void exit(int status);
   ```
3. **atexit**
   
   ```c
    #include <stdlib.h>

    // 将 function 加到一个函数列表中，进程终止时会调用该函数列表的所有函数。
    int atexit(void (*function)(void));
        成功: 返回0
        失败: 返回非0
   ```

### 3. 监控子进程

1. **等待进程退出**

   1. **wait**
   
       ```c
        #include <sys/wait.h>
        
        // 等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回 该子进程的终止状态。
        pid_t wait(int *stat_loc);
            成功: 返回退出的子进程id
            失败: 返回-1, 并设置errno
       ```

   2. **waitpid**
    
       > 可等待某个特定子进程的完成。

       > 可以阻塞等待或非阻塞等待。
       
       > 可获得因信号停止的子进程信息。

       ```c
       #include <sys/types.h>
       #include <sys/wait.h>
       
       // 如果 pid 大于 0，表示等待进程 ID 为 pid 的子进程。
       // 如果 pid 等于 0，则等待与调用进程(父进程)同一个进程组(process group)的所有 子进程。
       // 如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程。
       // 如果 pid 等于-1，则等待任意子进程。
       pid_t waitpid(pid_t pid, int *wstatus, int options);
       ```

       `options`:
       
       `WUNTRACED`: 除了返回终止子进程的信息外，还返回因信号而停止的子进程信息。

       `WCONTINUED`: 返回因收到 SIGCONT 信号而恢复执行的已停止子进程的状态信息。
        
       `WNOHANG`: 如果参数 pid 所指定的子进程并未发生状态改变，则立即返回，而不会阻塞
    
   3. **state**
      > 由 wait()和 waitpid()返回的 status 的值，可用来区分以下子进程事件。
       - 子进程调用_exit()(或 exit())而终止，并指定一个整型值作为退出状态。
       - 子进程收到未处理信号而终止。
       - 子进程因为信号而停止，并以 WUNTRACED 标志调用 waitpid()。
       - 子进程因收到信号 SIGCONT 而恢复，并以 WCONTINUED 标志调用 waitpid()。
  
        <br />

        ```c
        // 子进程正常结束则返回真(true)。
        WIFEXITED (status)

        // 返回子进程的退出 状态。
        WEXITSTATUS(status)

        // 通过信号杀掉子进程则返回真(true)。
        WIFSIGNALED (status)

        // 返回导致子进程终止 的信号编号。
        WTERMSIG(status)

        // 子进程因信号而停止，则此宏返回为真值(true)。 
        WIFSTOPPED (status)

        // 子进程收到 SIGCONT 而恢复执行，则此宏返回真值(true)。
        WIFCONTINUED (status)
        ```

2. **孤儿进程和僵尸进程**
   
   > 进程 ID 为 1 的init会接管孤儿进程。

   > 子进程退出后，父进程未执行wait系列函数获取子进程退出信息后内核把子进程转为僵尸进程。

3. **回收进程方法（通过SIGCHLD信号）**
   
   ```c
    //在信号处理程序中
    while (waitpid(-1, NULL,WNOHANG) > 0)
        continue;
   ```

4. **忽略终止的子进程**
   
   > (Solaris 8) 对 SIGCHLD 的处置显式置为 SIG_ IGN，系统从而会将其后终止的子进程立即删除，不转为僵尸进程。

### 4. 执行新程序

1. **exec系列函数**
   
   > 将新程序加载到某一进程的内存空间。在这一操作过程中，将丢弃 旧有程序，而进程的栈、数据以及堆段会被新程序的相应部件所替换。

   > 默认情况下，由 exec()的调用程序所打开的所有文件描述符在 exec()的执行过程中会保持 打开状态，且在新程序中依然有效。

   > 内核为每个文件描述符提供了执行时关闭标志(FD_CLOEXEC )。如果设置了这一标志，那么在成 功执行 exec()时，会自动关闭该文件描述符，如果调用 exec()失败，文件描述符则会保持打开 状态。

   > exec()在执行时会将现有进程的文本段丢弃。该文本段可能包含了由调用进程创建的信号 处理器程序。既然处理器已经不知所踪，内核就会将对所有已设信号的处置重置为 SIG_DFL。

   ```c
    #include <unistd.h>


    int execl(const char *pathname, const char *arg, ...
                    /* (char  *) NULL */);
    int execlp(const char *file, const char *arg, ...
                    /* (char  *) NULL */);
    int execle(const char *pathname, const char *arg, ...
                    /*, (char *) NULL, char *const envp[] */);
    int execv(const char *pathname, char *const argv[]);

    int execvp(const char *file, char *const argv[]);

        成功: 从不返回
        失败: 返回-1, 并设置errno
   ```

   ![alt text](<image-9.png>)
2. **执行shell命令**
   
   ```c
    #include <stdlib.h>

    int system(const char *command);

    返回值:
        * 当command为NULL指针时，如果shell可用则system()返回非0值，若不可用则返回0。
        * 如果无法创建子进程或是无法获取其终止状态，那么 system()返回-1。
        * 若子进程不能执行shell，则system()的返回值会与子shell调用_exit(127)终止时一样。
        * 如果所有的系统调用都成功，system()会返回执行 command 的子 shell 的终止状态。

   ```
   