## 线程

### 1. 介绍

> 一个进程可以包含多个线程。同一程序中的所有线程均会独立执行相同程序， 且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。
> 在 Linux 平台上，在编译调用了 Pthreads API 的程序时，需要设置 gcc -lpthread 的编译选项。

![alt text](<image-10.png>)

1. **线程对比进程的优势**
   
   1. 线程之间能够方便、快速地共享信息。只需将数据复制到共享(全局或堆)变量中即可。
   2. 创建线程比创建进程通常要快 10 倍甚至更多。
   
2. **创建线程**
   
   ```c
    // 常用宏定义
    #include <errno.h>
    #include <stdlib.h>

    #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

    #define handle_error(msg) \
            do { perror(msg); exit(EXIT_FAILURE); } while (0)
   ```

   ```c
    #include <pthread.h>

    // 参数 thread: 线程成功创建后, 该参数保存一个该线程的唯一标识。
    // 参数 attr 是指向 pthread_attr_t 对象的指针，该对象指定了新线程的各种属性
    // 新线程通过调用带有参数 arg 的函数 start_routine 而开始执行。
    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
        成功: 返回0
        失败: 返回errno
   ```
3. **终止线程**
   
    ```c
    #include <pthread.h>

    // pthread_exit()函数将终止调用线程
    // 参数 retval 指定了线程的返回值。Retval 所指向的内容不应分配于线程栈中
    void pthread_exit (void *retval);
    ```
   1. 线程 start 函数执行 return 语句并返回指定值。
   2. 线程调用 pthread_exit()
   3. 调用 pthread_cancel()取消线程
   4. 任意线程调用了 exit()，或者主线程执行了 return 语句(在 main()函数中)，都会导致进程中的所有线程立即终止。

4. **线程标识符**
   
   ```c
    #include <pthread.h>

    // 获取自己的线程 ID。
    pthread_t pthread_self(void);

    // 判断线程t1 和 线程t2是否相同，相同返回非0，否则返回0
    int pthread_equal(pthread_t t1, pthread_t t2);
   ```

5. **连接已终止的线程**

    > pthread_join 等待由 thread 标识的线程终止。(如果线程已经终止，pthread_join()会立即返回)。这种操作被称为连接(joining)。

   ```c
    #include <pthread.h>

    // 若 retval 为非空指针，将会保存线程终止时返回值的拷贝，该返回值亦即线程调用 return 或 pthred_exit()时所指定的值。
    int pthread_join(pthread_t thread, void **retval);
        成功: 返回0
        失败: 返回errno
   ```
6. **设置分离状态**
   
   > 默认情况下，线程是可连接的(joinable)，有时，并不关心线程的返回状态，通过设置pthread_detach()，系统在线程终止时能够自动清理并移除。

   ```c
    #include <pthread.h>

    // thread 参数传入指定线程的标识符，将该线程标记为处于分离(detached)状态。
    int pthread_detach(pthread_t thread);
        成功: 返回0
        失败: 返回errno
   ```

7. **线程属性**
   
   
   ```c
    #include <pthread.h>

    // 初始化
    int pthread_attr_init(pthread_attr_t *attr);

    // 删除
    int pthread_attr_destroy(pthread_attr_t *attr);
   ```

   ```c
   // 线程测试demo
    #include <stdio.h>
    #include <pthread.h>
    #include <errno.h>
    #include <stdlib.h>

    #define handle_error_en(en, msg) \
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

    #define handle_error(msg) \
        do { perror(msg); exit(EXIT_FAILURE); } while (0)


    void* thread(void *arg) {
        
        printf("thread %ld start...\n", pthread_self());
        printf("获取到参数arg: %d\n", *((int *)arg));
        
        return (void *)33;
    }
    int main(int argc, char *argv[]) {
        pthread_t t1;

        int arg = 10;
        int thread_ret = 0;

        int ret = pthread_create(&t1, NULL, thread, (void *)&arg);
        if (ret != 0) {
            handle_error_en(ret, "pthread_create");
        }

        ret = pthread_join(t1, (void **)&thread_ret);
        if (ret != 0) {
            handle_error_en(ret, "pthread_join");
        }
        printf("thread t1 ret = %d\n", thread_ret);
        printf("main thread end\n");
        
        return 0;
    }

    // gcc main.c -o thread_demo -lpthread
   ```

### 2. 线程同步

1. **互斥量**
   
   > 互斥量可以帮助线程同步对共享资源的使用，以防如下情况发生:线程某甲试图访问一共享变量时，线程某乙正在对其进行修改。

   > 一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥 量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。
   1. 每一线程在访问同一资源时将采用如下协议:
        - 针对共享资源锁定互斥量。
        - 访问共享资源。
        - 对互斥量解锁。
  
   <br />

   ```c
    #include <pthread.h>
    
    // 静态分配
    pthread_t mutex = PTHREAD_MUTEX_INITIALIZER;

    // 动态分配
    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
    
    // 动态分配互斥量释放
    int pthread_mutex_destroy(pthread_mutex_t *mutex);

    // 加锁
    int pthread_mutex_lock(pthread_mutex_t *mutex);

    // 解锁
    int pthread_mutex_unlock(pthread_mutex_t *mutex);

        成功: 返回0
        失败: 返回errno
   ```
2. **条件变量**
   
   > 条件变量允许一个线程就某个共享变量(或其他共享资源)的状态变化同志其他线程，并让其他线程等待（堵塞）这一通知。

   > 条件变量的主要操作是发送信号(signal)和等待(wait)。发送信号操作即通知一个或多 个处于等待状态的线程，某个共享变量的状态已经改变。等待操作是指在收到一个通知前一 直处于阻塞状态。

   ```c
    #include <pthread.h>

    // 静态初始化条件变量
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

    // 动态初始化条件变量
    int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);

    // 删除一个条件变量
    int pthread_cond_destroy(pthread_cond_t *cond);

    // 对参数 cond 指定的条件变量发送信号，只保证唤醒至少一条遭到阻塞的线程，
    int pthread_cond_signal(pthread_cond_t *cond);

    // 对参数 cond 指定的条件变量发送信号，唤醒所有遭阻塞的线程。
    int pthread_cond_broadcast(pthread_cond_t *cond);

    // 阻塞一线程，直至收到条件变量 cond 的通知
    // 解锁互斥量 mutex。
    // 堵塞调用线程，直至另一线程就条件变量 cond 发出信号。
    // 重新锁定 mutex。
    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
        
        成功: 返回0
        失败: 返回errno
   ```
